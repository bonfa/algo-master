# Exercise list
* Design HashMap
* Maximum Number of Balloons
* Number of Good Pairs
* Isomorphic Strings
* Ransom Note
* Contains Duplicate II
* Group Anagrams
* Encode and Decode TinyURL
* Reorganize String
* Longest Consecutive Sequence
* Split Array into Consecutive Subsequences
* Number of Matching Subsequences
* Number of Good Ways to Split a String


## Attempt 1
1. Design HashMap (SOLVED_OPTIMAL (for time))
2. Maximum Number of Balloons (SOLVED_NOT_OPTIMAL -> Solved with map not with array)
3. Number of Good Pairs (SOLVED_OPTIMAL -> better than Hashish solution)
4. Isomorphic Strings (SOLVED_SUB_OPTIMAL -> very similar to best solution, just used one map rather than two)
5. Ransom note (SOLVED_OPTIMAL)
6. Contains duplicate II (SOLVED_SUB_OPTIMAL -> built a map and applied filter later, could have done it in place)
7. Group Anagrams (SOLVED_SUB_OPTIMAL -> the idea was correct. I just used less efficient data structures)
8. Encode and Decode TinyURL  (SOLVED_SUB_OPTIMAL -> I skipped the incremental value. I did not use base64 as encoding. I used a custom solution)
9. Reorganize String (SOLVED_SUB_OPTIMAL -> used a map, not a priority queue)
10. Longest Consecutive Sequence (SOLVED_SUB_OPTIMAL -> the solution fails with long inputs)
11. Split Array into Consecutive Subsequences (NOT_SOLVED -> tried to solve it by reasoning on the frequency of the numbers but the solution was not working)
12. Number of Matching Subsequences (SOLVED_SUB_OPTIMAL -> first solution "brute force", then improved. still not using binary search)
13. Number of Good Ways to Split a String (SOLVED_SUB_OPTIMAL -> the idea was there, but I could have improved the implementation significantly)


# Revision List
## After Attempt 1
TBD